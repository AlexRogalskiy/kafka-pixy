package config

import (
	"crypto/rand"
	"errors"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v2"
)

// T defines Kafka-Pixy configuration. It mirrors the structure of JSON
// configuration file.
type T struct {
	// TCP address that Kafka-Pixy should listen at.
	TCPAddr string `yaml:"tcp_addr"`

	// Unix domain socket address that Kafka-Pixy should listen at. Listening
	// on a unix domain socket is disabled by default.
	UnixAddr string `yaml:"unix_addr"`

	// Unique ID that identifies a Kafka-Pixy instance in both ZooKeeper and
	// Kafka. It is automatically generated by default and it is recommended to
	// leave it like that.
	ClientID string `yaml:"client_id"`

	Kafka struct {

		// List of seed Kafka peers that Kafka-Pixy should access to resolve
		// the Kafka cluster topology.
		SeedPeers []string `yaml:"seed_peers"`
	} `yaml:"kafka"`

	ZooKeeper struct {

		// List of seed ZooKeeper peers that Kafka-Pixy should access to
		// resolve the ZooKeeper cluster topology.
		SeedPeers []string `yaml:"seed_peers"`

		// Path to the directory where Kafka keeps its data.
		Chroot string `yaml:"chroot"`
	} `yaml:"zoo_keeper"`

	Producer struct {

		// Size of all buffered channels created by the producer module.
		ChannelBufferSize int `yaml:"channel_buffer_size"`

		// Period of time that Kafka-Pixy should keep trying to submit buffered
		// messages to Kafka. It is recommended to make it large enough to survive
		// a ZooKeeper leader election in your setup.
		ShutdownTimeout time.Duration `yaml:"shutdown_timeout"`
	} `yaml:"producer"`

	Consumer struct {

		// Size of all buffered channels created by the consumer module.
		ChannelBufferSize int `yaml:"channel_buffer_size"`

		// Consume request will wait at most this long until a message from the
		// specified group/topic becomes available.
		LongPollingTimeout time.Duration `yaml:"long_polling_timeout"`

		// Period of time that Kafka-Pixy should keep registration with a
		// consumer group or subscription for a topic in the absence of
		// requests to the consumer group or topic.
		RegistrationTimeout time.Duration `yaml:"registration_timeout"`

		// If a request to a Kafka-Pixy fails for any reason, then it should
		// wait this long before retrying.
		BackOffTimeout time.Duration `yaml:"backoff_timeout"`

		// Consumer should wait this long after it gets notification that a
		// consumer joined/left its consumer group before starting rebalancing.
		RebalanceDelay time.Duration `yaml:"rebalance_delay"`

		// How frequently to commit offsets to Kafka.
		OffsetsCommitInterval time.Duration `yaml:"offsets_commit_interval"`
	} `yaml:"consumer"`
}

// Default returns configuration used by default.
func Default() *T {
	c := &T{}
	c.TCPAddr = "0.0.0.0:19092"
	c.ClientID = newClientID()
	c.ZooKeeper.SeedPeers = []string{"localhost:2181"}
	c.Kafka.SeedPeers = []string{"localhost:9092"}

	c.Producer.ChannelBufferSize = 4096
	c.Producer.ShutdownTimeout = 30 * time.Second

	c.Consumer.ChannelBufferSize = 64
	c.Consumer.LongPollingTimeout = 3 * time.Second
	c.Consumer.RegistrationTimeout = 20 * time.Second
	c.Consumer.BackOffTimeout = 500 * time.Millisecond
	c.Consumer.RebalanceDelay = 250 * time.Millisecond
	c.Consumer.OffsetsCommitInterval = 500 * time.Millisecond
	return c
}

// FromYAML parses configuration from a YAML file and performs basic
// validation of parameters. If error is returned then the original config is
// not modified.
func (c *T) FromYAMLFile(filename string) error {
	configFile, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer configFile.Close()
	data, err := ioutil.ReadAll(configFile)
	if err != nil {
		return err
	}

	if err := c.FromYAML(data); err != nil {
		return err
	}
	return nil
}

// FromYAML parses configuration from a YAML string and performs basic
// validation of parameters. If error is returned then the original config is
// not modified.
func (c *T) FromYAML(data []byte) error {
	clone := *c
	clone.Kafka.SeedPeers = make([]string, len(c.Kafka.SeedPeers))
	copy(clone.Kafka.SeedPeers, c.Kafka.SeedPeers)
	clone.ZooKeeper.SeedPeers = make([]string, len(c.ZooKeeper.SeedPeers))
	copy(clone.ZooKeeper.SeedPeers, c.ZooKeeper.SeedPeers)

	if err := yaml.Unmarshal(data, &clone); err != nil {
		return fmt.Errorf("failed to parse config: err=(%s)", err)
	}
	if err := clone.validate(); err != nil {
		return fmt.Errorf("invalid config parameter: err=(%s)", err)
	}
	*c = clone
	return nil
}

func (c *T) validate() error {
	// Validate the Producer parameters.
	switch {
	case c.Producer.ChannelBufferSize <= 0:
		return errors.New("Producer.ChannelBufferSize must be > 0")
	case c.Producer.ShutdownTimeout < 0:
		return errors.New("Producer.ShutdownTimeout must be >= 0")
	}
	// Validate the Consumer parameters.
	switch {
	case c.Consumer.ChannelBufferSize <= 0:
		return errors.New("Consumer.ChannelBufferSize must be > 0")
	case c.Consumer.LongPollingTimeout <= 0:
		return errors.New("Consumer.LongPollingTimeout must be > 0")
	case c.Consumer.RegistrationTimeout <= 0:
		return errors.New("Consumer.RegistrationTimeout must be > 0")
	case c.Consumer.BackOffTimeout <= 0:
		return errors.New("Consumer.BackOffTimeout must be > 0")
	case c.Consumer.RebalanceDelay <= 0:
		return errors.New("Consumer.RebalanceDelay must be > 0")
	case c.Consumer.OffsetsCommitInterval <= 0:
		return errors.New("Consumer.OffsetsCommitInterval must be > 0")
	}
	return nil
}

// newClientID creates a unique id that identifies this particular Kafka-Pixy
// in both Kafka and ZooKeeper.
func newClientID() string {
	hostname, err := os.Hostname()
	if err != nil {
		ip, err := getIP()
		if err != nil {
			buffer := make([]byte, 8)
			_, _ = rand.Read(buffer)
			hostname = fmt.Sprintf("%X", buffer)

		} else {
			hostname = ip.String()
		}
	}
	timestamp := time.Now().UTC().Format(time.RFC3339)
	// sarama validation regexp for the client ID doesn't allow ':' characters
	timestamp = strings.Replace(timestamp, ":", ".", -1)
	return fmt.Sprintf("pixy_%s_%s_%d", hostname, timestamp, os.Getpid())
}

func getIP() (net.IP, error) {
	interfaceAddrs, err := net.InterfaceAddrs()
	if err != nil {
		return nil, err
	}
	var ipv6 net.IP
	for _, interfaceAddr := range interfaceAddrs {
		if ipAddr, ok := interfaceAddr.(*net.IPNet); ok && !ipAddr.IP.IsLoopback() {
			ipv4 := ipAddr.IP.To4()
			if ipv4 != nil {
				return ipv4, nil
			}
			ipv6 = ipAddr.IP
		}
	}
	if ipv6 != nil {
		return ipv6, nil
	}
	return nil, errors.New("Unknown IP address")
}
